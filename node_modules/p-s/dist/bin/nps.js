#!/usr/bin/env node
'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
/* eslint no-process-exit: "off" */


var _findUp = require('find-up');

var _findUp2 = _interopRequireDefault(_findUp);

var _lodash = require('lodash');

var _commander = require('commander');

var _commander2 = _interopRequireDefault(_commander);

var _safe = require('colors/safe');

var _safe2 = _interopRequireDefault(_safe);

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _binUtils = require('../bin-utils');

var _getLogger = require('../get-logger');

var _getLogger2 = _interopRequireDefault(_getLogger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _require = require('../../package.json'),
    version = _require.version;

var log = (0, _getLogger2.default)();
var FAIL_CODE = 1;
var shouldRun = true;
var shouldAutocomplete = (0, _lodash.includes)(process.argv, '--compbash');

_commander2.default.version(version).allowUnknownOption().option('-s, --silent', 'Silent nps output').option('-p, --parallel <script-name1,script-name2>', 'Scripts to run in parallel (comma seprated)').option('-c, --config <filepath>', 'Config file to use (defaults to nearest package-scripts.yml or package-scripts.js)').option('-l, --log-level <level>', 'The log level to use (error, warn, info [default])').option('-r, --require <module>', 'Module to preload').on('init', onInit).on('completion', onRequestToInstallCompletion).on('--help', onHelp).parse(process.argv);

if (shouldAutocomplete) {
  (0, _binUtils.autocomplete)(getPSConfig());
} else if (shouldRun) {
  var psConfig = getPSConfig();
  var hasDefaultScript = !!psConfig.scripts.default;
  var scriptsAndArgs = (0, _binUtils.getScriptsAndArgs)(_commander2.default);
  var hasHelpScript = !!psConfig.scripts.help;
  var scriptIsHelp = scriptsAndArgs.scripts[0] === 'help';
  var scriptSpecified = scriptsAndArgs.scripts.length >= 1;
  if (!hasDefaultScript && !scriptSpecified) {
    _commander2.default.outputHelp();
  } else if (!hasHelpScript && scriptIsHelp) {
    // eslint-disable-line no-negated-condition
    _commander2.default.outputHelp();
  } else {
    loadAndRun(scriptsAndArgs, psConfig);
  }
}

function loadAndRun(scriptsAndArgs, psConfig) {
  (0, _index2.default)({
    scriptConfig: psConfig.scripts,
    scripts: scriptsAndArgs.scripts,
    args: scriptsAndArgs.args,
    options: (0, _lodash.merge)(psConfig.options, {
      silent: _commander2.default.silent,
      parallel: scriptsAndArgs.parallel,
      logLevel: _commander2.default.logLevel
    })
  }).catch(function (error) {
    log.error(error);
    process.exitCode = error.code || FAIL_CODE;
  });
}

function getPSConfig() {
  if (_commander2.default.require) {
    (0, _binUtils.preloadModule)(_commander2.default.require);
  }
  var configFilepath = getPSConfigFilepath();
  if (!configFilepath) {
    log.warn(_safe2.default.yellow('Unable to find a config file and none was specified.'));
    return { scripts: {} }; // empty config
  }
  var config = (0, _binUtils.loadConfig)(configFilepath);
  if (!config) {
    process.exit(FAIL_CODE);
  }
  return config;
}

function getPSConfigFilepath() {
  return _commander2.default.config || _findUp2.default.sync('package-scripts.js') || _findUp2.default.sync('package-scripts.yml');
}

function onInit() {
  shouldRun = false;

  var _initialize = (0, _binUtils.initialize)(getConfigType()),
      packageScriptsPath = _initialize.packageScriptsPath;

  log.info('Your scripts have been saved at ' + _safe2.default.green(packageScriptsPath));
  log.info(_safe2.default.gray('Check out your scripts in there. Go ahead and update them and add descriptions to the ones that need it'));
  log.info(_safe2.default.gray('Your package.json scripts have also been updated. Run `npm start help` for help'));
  log.info(_safe2.default.gray('You may also want to install the package globally and installing autocomplete script. You can do so by running\n' + '  npm install --global p-s\n' + '  nps completion <optionally-your-bash-profile-file>\n' + 'The bash profile file defaults to ~/.bash_profile for bash and ~/.zshrc for zsh'));
}

function getConfigType() {
  return (0, _lodash.includes)(process.argv, '--type') ? process.argv[(0, _lodash.indexOf)(process.argv, '--type') + 1] : 'js';
}

function onHelp() {
  shouldRun = false;
  log.info((0, _binUtils.help)(getPSConfig()));
}

function onRequestToInstallCompletion() {
  shouldRun = false;

  var _process$argv = _slicedToArray(process.argv, 4),
      destination = _process$argv[3];

  if (destination) {
    log.info('Installing p-s autocomplete into ' + destination);
  } else {
    log.info('Installing p-s autocomplete into the default for your current terminal');
  }
  log.info('You\'re going to need to either resource that file, or open a new instance of ' + 'the terminal to get autocomplete to start working');
  (0, _binUtils.installAutocomplete)(destination);
}